//go:build ignore

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

// Route represents a parsed route
type Route struct {
	FilePath    string
	Package     string
	HandlerName string
	Method      string
	URLPath     string
	HasParams   bool
	Params      []string
}

var methodMap = map[string]string{
	"get":    "GET",
	"post":   "POST",
	"put":    "PUT",
	"patch":  "PATCH",
	"delete": "DELETE",
}

// Parse [param] from filename
var paramRegex = regexp.MustCompile(`\[([^\]]+)\]`)

func main() {
	routesDir := "routes"
	if len(os.Args) > 1 {
		routesDir = os.Args[1]
	}

	routes, err := scanRoutes(routesDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error scanning routes: %v\n", err)
		os.Exit(1)
	}

	if err := generateRouter(routes, routesDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating router: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %d routes in %s/router_gen.go\n", len(routes), routesDir)
}

func scanRoutes(rootDir string) ([]Route, error) {
	var routes []Route

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		// Skip generated files and non-handler files
		filename := info.Name()
		if strings.HasPrefix(filename, "router") || filename == "init.go" {
			return nil
		}

		// Parse filename: name.method.go
		parts := strings.Split(strings.TrimSuffix(filename, ".go"), ".")
		if len(parts) < 2 {
			return nil // Not a route file
		}

		methodStr := strings.ToLower(parts[len(parts)-1])
		method, ok := methodMap[methodStr]
		if !ok {
			return nil // Not a valid method
		}

		name := strings.Join(parts[:len(parts)-1], ".")
		route := parseRoute(path, rootDir, name, method)
		routes = append(routes, route)

		return nil
	})

	// Sort routes for consistent output
	sort.Slice(routes, func(i, j int) bool {
		return routes[i].URLPath < routes[j].URLPath
	})

	return routes, err
}

func parseRoute(filePath, rootDir, name, method string) Route {
	// Get relative path from routes/
	relPath, _ := filepath.Rel(rootDir, filePath)
	dir := filepath.Dir(relPath)

	// Build URL path
	var urlParts []string
	if dir != "." {
		urlParts = strings.Split(dir, string(filepath.Separator))
	}

	// Handle index files (map to parent directory)
	if name != "index" {
		// Check for params [id]
		if paramRegex.MatchString(name) {
			name = paramRegex.ReplaceAllString(name, "{$1}")
		}
		urlParts = append(urlParts, name)
	}

	urlPath := "/" + strings.Join(urlParts, "/")

	// Extract params
	var params []string
	matches := paramRegex.FindAllStringSubmatch(urlPath, -1)
	for _, m := range matches {
		if len(m) > 1 {
			params = append(params, m[1])
		}
	}

	// Determine package
	pkg := "routes"
	if dir != "." {
		pkg = strings.ReplaceAll(dir, string(filepath.Separator), "_")
	}

	// Handler name: toCamelCase(name) + toCamelCase(method)
	handlerName := toCamelCase(strings.ReplaceAll(name, "{", "").Replace("}", "")) + toCamelCase(strings.ToLower(method))

	return Route{
		FilePath:    filePath,
		Package:     pkg,
		HandlerName: handlerName,
		Method:      method,
		URLPath:     urlPath,
		HasParams:   len(params) > 0,
		Params:      params,
	}
}

func toCamelCase(s string) string {
	s = strings.ReplaceAll(s, "[", "")
	s = strings.ReplaceAll(s, "]", "")
	s = strings.ReplaceAll(s, "{", "")
	s = strings.ReplaceAll(s, "}", "")

	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == '/'
	})

	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

const routerTemplate = `// Code generated by gen-routes. DO NOT EDIT.

package routes

import (
	"net/http"

	"github.com/gorilla/mux"

	{{- range .Imports }}
	{{ . }}
	{{- end }}
)

// RegisterRoutes registers all file-based routes
func RegisterRoutes(r *mux.Router, deps *Dependencies) {
	{{- range .Routes }}
	r.HandleFunc("{{ .URLPath }}", {{ .HandlerCall }}).Methods("{{ .Method }}")
	{{- end }}
}
`

type RouterData struct {
	Imports []string
	Routes  []RouteData
}

type RouteData struct {
	URLPath     string
	Method      string
	HandlerCall string
}

func generateRouter(routes []Route, outputDir string) error {
	// For now, use simple inline handlers
	data := RouterData{}

	for _, r := range routes {
		// Simple handler call - will be defined in each file
		handlerCall := fmt.Sprintf("deps.%s", r.HandlerName)

		data.Routes = append(data.Routes, RouteData{
			URLPath:     r.URLPath,
			Method:      r.Method,
			HandlerCall: handlerCall,
		})
	}

	tmpl, err := template.New("router").Parse(routerTemplate)
	if err != nil {
		return err
	}

	outPath := filepath.Join(outputDir, "router_gen.go")
	f, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer f.Close()

	return tmpl.Execute(f, data)
}
